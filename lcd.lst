RC51 COMPILER V03.08.10.309,  LCD                09/20/21  10:49:45  PAGE  1

QCW(0x00002F32)

DOS RC51 COMPILER V03.08.10.309, COMPILATION OF MODULE LCD       
OBJECT MODULE PLACED IN E:\Microcontroller_C\Smart Home\lcd.obj
COMPILER INVOKED BY: QUIET GENERATEDEPFILE OJ(E:\Microcontroller_C\Smart Home\lc
            -d.obj) PIN(C:\Raisonance\Ride\Inc;C:\Raisonance\Ride\Inc\51) PIN(C:
            -\Raisonance\Ride\\inc\51\SiLabs) NOAM CD PR(E:\Microcontroller_C\Sm
            -art Home\lcd.lst) FP(NOFLOAT) IP NOIS UNSIGNEDCHAR ET(CHAR) PR PL(6
            -0) PW(80) OE(1) OT(7,SPEED) RB(0) MAXERR(25) MAXWAR(25) SM MOD517(N
            -ODP8,NOAU) 

stmt level    source
   1          /*
   2          ;Name:      Captain
   3          ;Datum:     25.04.2019
   4          ;Aufgabe:   Test C LCD Display (2 x16 Zeichen) am Port 3 angeschlo
            -ssen
   5          ;Controller:C8051F340
   6          ;Da der µC C8051F340 viel schneller getaktet ist, als das LCD-Disp
            -lay es verarbeiten kann,
   7          ;mussten die Warteschleifen entsprechend angepasst werden!
   8          */
   9          
  10          /* lcd.c *********************************************************
            -*************************
  11           *        Funktionen zur Ansteuerung des LCD-Displays
  12           *****************************************************************
            -*************************/
  13           
  14          #include <C_8051F340.h>						//	Registeradressen											
  15          #include <intrins.h>						// für _crol_ -Funktion									
  16          #include <stdio.h>							//	für sprintf													
  17          
  18          unsigned char LCD_PORT;	
  19          #define LCD_PORT P0 						//	LCD-Display an P3 im Port-4-Bit-Modus
            -		
  20          
  21          void initlcd (void);													// Initialisierung
  22          void textlcd (unsigned char *text, unsigned char zeile);	// Textau
            -sgabe in Zeile 1 bis 4
  23          //void definierelcdsymbol (unsigned char pixelprozeile [8],unsigne
            -d char adr);
  24          														// Definition von max 7 eigenen Zeichen Adr 1 bis 7
  25          void LCDbefehl (unsigned char befehl);		// Ausgabe von Befehlen la
            -ut Datenblatt
  26          void charlcd (unsigned char zeichen);		// Ausgabe eines Zeichens a
            -n die aktuelle Cursorposition
  27          void cursorpos (unsigned char position);	// Setzen der Cursorposit
            -ion
  28          
  29          /*****************************************************************
            -*************************
  30           *  Zeitverzögerung:  wartet ca.  anzahl mal 100µs                
            -                                     
  31           *****************************************************************
            -*************************/
  32          void warte100u (int anzahl)	
  33          	{
  34   1      	int z1,z2;
RC51 COMPILER V03.08.10.309,  LCD                09/20/21  10:49:45  PAGE  2

  35   1      	for (z2 = anzahl;	z2 != 0;	--z2)
  36   1      		{
  37   2      		for (z1 = 3; 	z1!= 0; 	--z1);
  38   2      		};
  39   1      	}
  40          
  41          /*****************************************************************
            -************************
  42           * 	Gibt das Byte  befehl  als Befehl an LCD-Display im 4Bit-Modus
            -                              
  43           *      Entweder Busy-Flag des LCD abfragen oder Zeitverzögerung v
            -erwenden        
  44           *****************************************************************
            -************************/
  45          void LCDbefehl (unsigned char befehl)		
  46          	{	
  47   1      	unsigned char a1;
  48   1      	a1 = befehl;
  49   1      	a1 = _crol_ (a1,4); 			// in intrins.h, char um 4 Bits rolieren -
            -> High und Lownibbel vertauschen 													
  50   1      	a1 = (a1 & 0x0F) | 0x10;	//	4 Bits maskieren, Übergabetakt = 1, H
            -igh-Nibbel senden	
  51   1      	LCD_PORT = a1;
  52   1      	LCD_PORT = a1 & 0x00;		// Takt = 0 																
  53   1      	a1 = befehl;					// Low-Nibbel																
  54   1      	a1 = (a1 & 0x0F) | 0x10;	//	4 Bits maskieren, Übergabetakt = 1			
            -					
  55   1      	LCD_PORT = a1;
  56   1      	LCD_PORT = a1 & 0x00;		// Takt = 0 																
  57   1      	
  58   1      //***** Busy-Abfrage *********************************************
            -**************************	
  59   1      	warte100u(200);
  60   1          /*
  61   1          do {
  62   1      		LCD_PORT = 0x5F;			//  Busy lesen, Takt=1, RS = 0										
  63   1      		a1 = LCD_PORT	;			//	und holen																
  64   1      		LCD_PORT = 0x4F;			//	Takt=0																	
  65   1      		//a = a;
  66   1      		LCD_PORT = 0x5F;			//	Low-Byte holen (ohne Bedeutung)									
  67   1      		LCD_PORT = 0x4F;		
  68   1      		}
  69   1      	while ( (a1 & 0x08) != 0 ); //	warten solange Busy high
  70   1          */
  71   1       //***** Ende Busy-Abfrage ***************************************
            -***************************
  72   1      	
  73   1      //	wenn Busy nicht geht, Zeitverzögerung 1ms verwenden 	**********
            -************************
  74   1      //	warte100u (10);
  75   1      
  76   1      	}
  77          
  78          /*****************************************************************
            -******************
  79           * Pixelweise Definition eigener LCD-Zeichen, Ablegen von max 7 Ze
            -ichen im CG-RAM des LCD
  80           *****************************************************************
RC51 COMPILER V03.08.10.309,  LCD                09/20/21  10:49:45  PAGE  4

            -******************/
  81          /*
  82          void definierelcdsymbol (unsigned char pixelprozeile [8],unsigned 
            -char adr)
  83          	{unsigned char z;
  84          	if ((adr>0) & (adr<8)) 									// Adr0 geht nicht !????, max Adr
            - 7
  85          	LCDbefehl (((adr*8) & 0x7F) | 0x40);	
  86          	// Adresse der ersten Pixelzeile = 8 x Adresse des fertigen Zeich
            -ens im DD Ram
  87          	// Zugriff auf Adresse im CG-RAM (Character Generator) mit  Bit7 
            -= 0, Bit6 = 1
  88          	for (z=0;z<8;z++)	charlcd (pixelprozeile[z]);	//	8 Pixelzeilen in
            -s CR-Ram
  89          	cursorpos (0);												// wieder auf DD-Ram-Zugriff umschalten
            -		
  90          	}
  91          */	
  92          /*****************************************************************
            -*************************
  93           * Initialisierung des LCD- Displays für den 4-Bit-Modus          
            -                                     
  94           *****************************************************************
            -*************************/
  95          void initlcd (void)				
  96          	{ 
  97   1      	LCD_PORT = 0x13;			//	aufwecken! 	Takt=1	00010011											
  98   1      	LCD_PORT = 0x03;			//					Takt=0	00000011											
  99   1      	warte100u (200);			//	warten		       													
 100   1      	LCD_PORT = 0x13;			//	aufwecken! 	Takt=1														
 101   1      	LCD_PORT = 0x03;			//					Takt=0														
 102   1      	warte100u (200);				//	warten		      												
 103   1      	LCD_PORT = 0x13;			//	aufwecken! 	Takt=1														
 104   1      	LCD_PORT = 0x03;			//				Takt=0															
 105   1      	warte100u (200);				//	warten		       												
 106   1      	LCD_PORT = 0x12;			//	8->4  BITS UMSCHALTEN,	Takt=1										
 107   1      	LCD_PORT = 0x02;   		//						Takt=0													
 108   1      	warte100u (200);				//	warten		       												
 109   1      	LCDbefehl (0x28);			//	Function set 4 bits  													
 110   1      	LCDbefehl (0x0C);			//	Display AN, Cursor AUS													
 111   1      	LCDbefehl (0x06);			//	Not Shifted Display, Increment				
 112   1      	}
 113          
 114          /*****************************************************************
            -*************************
 115           * Display löschen	                                               
            -                                                       
 116           *****************************************************************
            -*************************/
 117          void loeschenlcd (void)		
 118          	{	LCDbefehl (0x01);	}
 119          
 120          /*****************************************************************
            -************************
 121           * 	Ausgabe eines Zeichens an das LCD-Display                     
            -                                     
 122           *      Entweder Busy-Flag des LCD abfragen oder Zeitverzögerung v
            -erwenden         
RC51 COMPILER V03.08.10.309,  LCD                09/20/21  10:49:45  PAGE  6

 123           *****************************************************************
            -*************************/
 124          void charlcd (unsigned char zeichen)	
 125          	{
 126   1      	unsigned char a1;
 127   1      	a1 = zeichen ;	
 128   1      //	al >> 4;
 129   1      	a1 = _crol_ (a1,4); 	// in intrins.h, char um 4 Bits rolieren -> 
            -High und Lownibbel 
 130   1      								//	vertauschen im Debugger getestet, geht 																
            -			
 131   1      	a1 = (a1 & 0x0F) | 0x90;	//	4 Bits maskieren, Übergabetakt = 1, H
            -igh-Nibbel senden	
 132   1      	LCD_PORT = a1;
 133   1      	LCD_PORT = a1 & 0x80;		// Takt = 0 																
 134   1      	a1 = zeichen;					// Low-Nibbel																
 135   1      	a1 = (a1 & 0x0F) | 0x90;	//	4 Bits maskieren, Übergabetakt = 1			
            -					
 136   1      	LCD_PORT = a1;
 137   1      	LCD_PORT = a1 & 0x80;		// Takt = 0 																
 138   1      	
 139   1      //**** Busy-Abfrage **********************************************
            -*************************	
 140   1          warte100u(200);
 141   1          /*    
 142   1      	do {
 143   1      		LCD_PORT = 0x5F;			//  Busy lesen, Takt=1, RS = 0										
 144   1      		a1 = LCD_PORT	;			//	und holen																
 145   1      		LCD_PORT = 0x4F;			//	Takt=0																	
 146   1      		//a = a;
 147   1      		LCD_PORT = 0x5F;			//	Low-Byte holen (ohne Bedeutung)									
 148   1      		LCD_PORT = 0x4F;		
 149   1      		}
 150   1      	while ( (a1 & 0x08) != 0 ); //	warten solange Busy high
 151   1          */
 152   1       //**** Ende Busy-Abfrage ****************************************
            -**************************	
 153   1      	
 154   1      //	wenn Busy nicht geht, Zeitverzögerung 1ms verwenden ***********
            -*************************
 155   1      //	warte100u (10);
 156   1      	} 
 157          
 158          /*****************************************************************
            -************************
 159           * LCD-Cursor auf eine position setzen: Zeile 1: Adresse 0x00 bis 
            -0x0F                     
 160           *                                      Zeile 2: Adresse 0x40 bis 
            -0x4F  
 161           *                                      Zeile 3: Adresse 0x10 bis 
            -0x1F
 162           *													 Zeile 4: Adresse 0x50 bis 0x5F                   
 163           *****************************************************************
            -*************************/
 164          void cursorpos (unsigned char position)
 165          	{ 	LCDbefehl ( position | 0x80 ); }	// Kennung für DD RAM address
            - set							
 166          
RC51 COMPILER V03.08.10.309,  LCD                09/20/21  10:49:45  PAGE  7

 167          /*****************************************************************
            -************************
 168           * LCD-Cursor auf die Position Home 0x00 setzen                   
            -                        
 169           *****************************************************************
            -*************************/	
 170          void cursorhome (void)
 171          	{	LCDbefehl (0x02 );	}
 172          
 173          /*****************************************************************
            -************************
 174           * Text an das LCD-Display in Zeile 1 bsi 4 ausgeben              
            -            
 175           *****************************************************************
            -*************************/
 176          void textlcd (unsigned char *text, unsigned char zeile)									
 177          	{
 178   1      	if 	(zeile == 1)	{ cursorpos (0x00);}	//	LCD-Zeile 1											
 179   1      	if    (zeile == 2) 	{ cursorpos (0x40);}	// LCD-Zeile 2			
 180   1      	if		(zeile == 3)   { cursorpos (0x10);} // LCD-Zeile 3	
 181   1      	if    (zeile == 4)   { cursorpos (0x50);} // LCD-Zeile 4   						
            -	
 182   1      	while (*text)
 183   1          {        //	Text													
 184   2      	  charlcd(*text++); 
 185   2            warte100u(200);
 186   2          }
 187   1          //	zeichenweise ausgeben 							
 188   1      	}
 189          
 190          
RC51 COMPILER V03.08.10.309,  LCD                09/20/21  10:49:45  PAGE  9

ASSEMBLY LISTING OF GENERATED OBJECT CODE

            ; FUNCTION _warte100u (BEGIN)
              ; Register R6R7 is assigned to parameter anzahl
              ; R2R3 is assigned to z1
              ; R4R5 is assigned to z2
                                           ; SOURCE LINE # 35 
0000 8E04           MOV    AR4,R6
0002 8F05           MOV    AR5,R7
0004         ?FOR2:
0004 EC             MOV    A,R4
0005 4D             ORL    A,R5
0006 6016           JZ     ?NXT4
                                           ; SOURCE LINE # 37 
0008 E4             CLR    A
0009 FA             MOV    R2,A
000A 7B03           MOV    R3,#003H
000C         ?FOR3:
000C EA             MOV    A,R2
000D 4B             ORL    A,R3
000E 6007           JZ     ?NXT5
0010 EB             MOV    A,R3
0011 1B             DEC    R3
0012 70F8           JNZ    ?FOR3
0014 1A             DEC    R2
0015 80F5           SJMP   ?FOR3
0017         ?NXT5:
                                           ; SOURCE LINE # 35 
0017 ED             MOV    A,R5
0018 1D             DEC    R5
0019 70E9           JNZ    ?FOR2
001B 1C             DEC    R4
001C 80E6           SJMP   ?FOR2
001E         ?NXT4:
                                           ; SOURCE LINE # 39 
001E 22             RET    

            ; FUNCTION _warte100u (END)

            ; FUNCTION _LCDbefehl (BEGIN)
              ; Register R7 is assigned to parameter befehl
              ; R6 is assigned to a1
                                           ; SOURCE LINE # 49 
0000 75F004         MOV    B,#004H
0003 EF             MOV    A,R7
0004         ?LAB8:
0004 23             RL     A
0005 D5F0FC         DJNZ   B,?LAB8
                                           ; SOURCE LINE # 50 
0008 540F           ANL    A,#00FH
000A 4410           ORL    A,#010H
                                           ; SOURCE LINE # 51 
000C F580           MOV    P0,A
                                           ; SOURCE LINE # 52 
000E E4             CLR    A
000F F580           MOV    P0,A
              ; R6 is assigned to a1
                                           ; SOURCE LINE # 54 
0011 EF             MOV    A,R7
0012 540F           ANL    A,#00FH
RC51 COMPILER V03.08.10.309,  LCD                09/20/21  10:49:45  PAGE  3

0014 4410           ORL    A,#010H
                                           ; SOURCE LINE # 55 
0016 F580           MOV    P0,A
                                           ; SOURCE LINE # 56 
0018 E4             CLR    A
0019 F580           MOV    P0,A
                                           ; SOURCE LINE # 59 
001B FE             MOV    R6,A
001C 7FC8           MOV    R7,#0C8H
001E 020000  R      LJMP   _warte100u

            ; FUNCTION _LCDbefehl (END)

            ; FUNCTION initlcd (BEGIN)
                                           ; SOURCE LINE # 97 
0000 758013         MOV    P0,#013H
                                           ; SOURCE LINE # 98 
0003 758003         MOV    P0,#003H
                                           ; SOURCE LINE # 99 
0006 E4             CLR    A
0007 FE             MOV    R6,A
0008 7FC8           MOV    R7,#0C8H
000A 120000  R      LCALL  _warte100u
                                           ; SOURCE LINE # 100 
000D 758013         MOV    P0,#013H
                                           ; SOURCE LINE # 101 
0010 758003         MOV    P0,#003H
                                           ; SOURCE LINE # 102 
0013 120000  R      LCALL  _warte100u
                                           ; SOURCE LINE # 103 
0016 758013         MOV    P0,#013H
                                           ; SOURCE LINE # 104 
0019 758003         MOV    P0,#003H
                                           ; SOURCE LINE # 105 
001C 120000  R      LCALL  _warte100u
                                           ; SOURCE LINE # 106 
001F 758012         MOV    P0,#012H
                                           ; SOURCE LINE # 107 
0022 758002         MOV    P0,#002H
                                           ; SOURCE LINE # 108 
0025 120000  R      LCALL  _warte100u
                                           ; SOURCE LINE # 109 
0028 7F28           MOV    R7,#028H
002A 120000  R      LCALL  _LCDbefehl
                                           ; SOURCE LINE # 110 
002D 7F0C           MOV    R7,#00CH
002F 120000  R      LCALL  _LCDbefehl
                                           ; SOURCE LINE # 111 
0032 7F06           MOV    R7,#006H
0034 020000  R      LJMP   _LCDbefehl

            ; FUNCTION initlcd (END)

            ; FUNCTION loeschenlcd (BEGIN)
                                           ; SOURCE LINE # 118 
0000 7F01           MOV    R7,#001H
0002 020000  R      LJMP   _LCDbefehl

RC51 COMPILER V03.08.10.309,  LCD                09/20/21  10:49:45  PAGE  5

            ; FUNCTION loeschenlcd (END)

            ; FUNCTION _charlcd (BEGIN)
              ; Register R7 is assigned to parameter zeichen
              ; R6 is assigned to a1
                                           ; SOURCE LINE # 129 
0000 75F004         MOV    B,#004H
0003 EF             MOV    A,R7
0004         ?LAB16:
0004 23             RL     A
0005 D5F0FC         DJNZ   B,?LAB16
                                           ; SOURCE LINE # 131 
0008 540F           ANL    A,#00FH
000A 4490           ORL    A,#090H
                                           ; SOURCE LINE # 132 
000C F580           MOV    P0,A
                                           ; SOURCE LINE # 133 
000E 5480           ANL    A,#080H
0010 F580           MOV    P0,A
              ; R6 is assigned to a1
                                           ; SOURCE LINE # 135 
0012 EF             MOV    A,R7
0013 540F           ANL    A,#00FH
0015 4490           ORL    A,#090H
                                           ; SOURCE LINE # 136 
0017 F580           MOV    P0,A
                                           ; SOURCE LINE # 137 
0019 5480           ANL    A,#080H
001B F580           MOV    P0,A
                                           ; SOURCE LINE # 140 
001D 7E00           MOV    R6,#000H
001F 7FC8           MOV    R7,#0C8H
0021 020000  R      LJMP   _warte100u

            ; FUNCTION _charlcd (END)

            ; FUNCTION _cursorpos (BEGIN)
              ; Register R7 is assigned to parameter position
                                           ; SOURCE LINE # 165 
0000 EF             MOV    A,R7
0001 4480           ORL    A,#080H
0003 FF             MOV    R7,A
0004 020000  R      LJMP   _LCDbefehl

            ; FUNCTION _cursorpos (END)

            ; FUNCTION cursorhome (BEGIN)
                                           ; SOURCE LINE # 171 
0000 7F02           MOV    R7,#002H
0002 020000  R      LJMP   _LCDbefehl

            ; FUNCTION cursorhome (END)

            ; FUNCTION _textlcd (BEGIN)
                                           ; SOURCE LINE # 176 
0000 8B00    R      MOV    text,R3
0002 8A00    R      MOV    text+01H,R2
0004 8900    R      MOV    text+02H,R1
RC51 COMPILER V03.08.10.309,  LCD                09/20/21  10:49:45  PAGE  8

0006 8D00    R      MOV    zeile,R5
                                           ; SOURCE LINE # 178 
0008 BD0105         CJNE   R5,#001H,?NXT13
000B E4             CLR    A
000C FF             MOV    R7,A
000D 120000  R      LCALL  _cursorpos
0010         ?NXT13:
                                           ; SOURCE LINE # 179 
0010 E500    R      MOV    A,zeile
0012 B40205         CJNE   A,#002H,?NXT14
0015 7F40           MOV    R7,#040H
0017 120000  R      LCALL  _cursorpos
001A         ?NXT14:
                                           ; SOURCE LINE # 180 
001A E500    R      MOV    A,zeile
001C B40305         CJNE   A,#003H,?NXT15
001F 7F10           MOV    R7,#010H
0021 120000  R      LCALL  _cursorpos
0024         ?NXT15:
                                           ; SOURCE LINE # 181 
0024 E500    R      MOV    A,zeile
0026 B40405         CJNE   A,#004H,?WHILE1
0029 7F50           MOV    R7,#050H
002B 120000  R      LCALL  _cursorpos
002E         ?WHILE1:
                                           ; SOURCE LINE # 182 
002E AB00    R      MOV    R3,text
0030 AA00    R      MOV    R2,text+01H
0032 A900    R      MOV    R1,text+02H
0034 120000  R      LCALL  IPGN1?C
0037 601E           JZ     ?NXT17
                                           ; SOURCE LINE # 184 
0039 AB00    R      MOV    R3,text
003B AA00    R      MOV    R2,text+01H
003D A900    R      MOV    R1,text+02H
003F 0500    R      INC    text+02H
0041 E500    R      MOV    A,text+02H
0043 7002           JNZ    ?LAB24
0045 0500    R      INC    text+01H
0047         ?LAB24:
0047 120000  R      LCALL  IPGN1?C
004A FF             MOV    R7,A
004B 120000  R      LCALL  _charlcd
                                           ; SOURCE LINE # 185 
004E E4             CLR    A
004F FE             MOV    R6,A
0050 7FC8           MOV    R7,#0C8H
0052 120000  R      LCALL  _warte100u
0055 80D7           SJMP   ?WHILE1
0057         ?NXT17:
                                           ; SOURCE LINE # 188 
0057 22             RET    

            ; FUNCTION _textlcd (END)

RC51 COMPILER V03.08.10.309,  LCD                09/20/21  10:49:45  PAGE 10



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    260    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1       6
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.

RC51 COMPILATION COMPLETE.  0 WARNING,  0 ERROR
